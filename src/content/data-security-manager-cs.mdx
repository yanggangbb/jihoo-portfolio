export const metadata = {
  title: "Data Security Manager CS 지식",
  date: "2025-06-23",
  excerpt: "Data Security Manager CS 조사 과제",
  category: "기타",
  imageUrl: "/images/cs/encryption1.png",
  award: "",
};

## 📁 CIA Triad: 정보 보안의 목표
기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)을 확보하여 정보 자산을 보호하는 것이 정보 보안의 목표
### 기밀성 (Confidentiality)
> **정보는 인가된 사용자나 시스템만이 접근할 수 있어야 함**
- 정보가 무단으로 공개되거나 유출되는 것을 방지하는 것
- 민감한 정보의 노출을 방지하고, 인가되지 않은 엑세스로부터 데이터를 보호하는 것을 목표
- 암호화, 엑세스 제어, 인증 및 인가 메커니즘, 물리적 보안 등이 사용
![Confidentiality](/images/cs/cia1.png)

### 무결성 (Integrity)
> **정보가 인가된 방법으로만 수정되거나 변경되지 않아야 함**
- 데이터가 손상되거나 조작되지 않아야 하며 정보의 정확성과 신뢰성을 보장하는 것을 목표
- 해시 함수, 디지털 서명, 버전 관리 시스템 등의 메커니즘이 사용
![Integrity](/images/cs/cia2.png)

### 가용성 (Availability)
> **정보나 시스템이 필요한 시간에 접근 가능하고 사용 가능해야 함**
- 시스템의 정상적인 작동을 보장하고, 서비스 거부 공격 등으로부터 시스템을 보호하여 사용자가 원하는 시간에 서비스를 이용할 수 있도록 하는 것을 목표
- 이중화, 재해 복구 계획, 네트워크 로드 밸런싱, 백업 및 복구 시스템 등의 메커니즘이 사용
![Availability](/images/cs/cia3.png)

## 🔐 암호학 기초
### 대칭 암호화 (Symmetric Encryption)
> **암복호화에 사용하는 키가 동일한 암호화 방식**  

![symmetric encryption](/images/cs/encryption1.png)
- 한 개의 비밀 키를 통해 데이터를 암호화 → 복호화
- 빠른 암호화 및 복호화 속도를 제공하므로 대량의 데이터를 암호화하는데 효과적   
    → 대량의 데이터를 암호화 해야 하는 파일 암호화, VPN, 디스크 암호화등에 사용
- 사용자 증가에 따른 키 분배와 관리의 어려움, 키가 노출되면 데이터의 보안이 위협   

`ex) DES, AES 등`

### 비대칭 암호화 (Asymmetric Encryption)
> **암호화하는 키와 복호화하는 키가 다른 방식**

![symmetric encryption](/images/cs/encryption2.png)
- 공개키(Public Key)와 비밀키(Private Key) 한 쌍 사용   
- 공개키로 암호화 → 비밀키로만 복호화 가능 → 키 관리 쉬움 
  - 공개키: 공개키는 누구나 접근할 수 있음
  - 비밀키: 비밀키는 공개키와 짝을 이루며 개인이 꼭 갖고 보안을 유지해야 함 

`ex) RSA 등`

#### 공개키 암호화 & 비밀키 복호화
"A 공개키"는 모든 사람이 접근 가능, "A 공개키"로 암호화를 해서 전송하면 "A 비밀키"로만 복호화할 수 있음  
→ 보안이 유지되어야 하는 내용을 전송하고 이것을 볼 수 있는 사람을 특정할 수 있음   
→ **기밀성**이 중요한 경우 사용되고 암호화된 메시지 전송(WhatsApp같은 비밀 메신저), 암호화폐 거래 정보 기록 등에 사용됨

ex) WhatsApp에서 A가 B에게 메세지를 보내는 경우
1. A는 메세지를 받을 B의 공개키를 통해 메세지를 암호화해서 전송
2. B는 A가 보낸 암호화된 메세지를 자신(B)의 개인키로 복호화하여 메세지를 확인
3. C가 B가 보내는 메세지를 중간에 탈취하더라도 C의 개인키로는 복호화할 수 없어 내용을 확인할 수 없음

#### 개인키 암호화 & 공개키 복호화
개인키로 암호화여 전송하며, 전송자의 공개키를 사용하여 누구나 복호화할 수 있음  
누구나 암호화된 데이터를 복호화할 수 있기 때문에 보안보다는 무결성과 신원 인증을 할 수 있다는 것이 중요  
본인이 갖고 있는 개인키로 암호화를 하기 때문에 B라는 사기꾼이 A인척 사칭을 해서 문서를 보내도 A의 공개키로 복호화가 안되기 때문에 신원인증이 되지 않음  
→ 본인임을 인증하는 디지털 서명, 블록체인 거래 서명, 전자 여권 등에 사용됨

### 해시 함수 (Hash Function)
> **임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수**  

![symmetric encryption](/images/cs/encryption3.png)
- 해시 함수를 수행하기 전의 원래의 데이터를 키 (key), 해시 함수를 수행한 결과값을 해시 값 (hash value)라고 함  
- 키를 해시 값으로 매핑하는 전체적인 과정을 해싱 (Hashing)이라고 함
- 동일한 입력이 주어지면 동일한 아웃풋을 생성하기 때문에 **데이터 무결성 확인**에 자주 사용
- 복호화가 불가능함
- ex) 파일 다운로드 시 checksum을 제공함으로써 다운받은 파일의 무결성을 확인할 수 있음
  <Figure
  src="/images/cs/encryption4.png"
  alt="symmetric encryption"
  caption="kali-installer-images checksum"
  width="60%"
  />
`ex) MD5, SHA-1, SHA-256 등`

#### 레인보우 테이블 (Rainbow Table)
해시 함수를 사용해 만든 해시값을 미리 계산하여 저장해 놓은 테이블  
![symmetric encryption](/images/cs/encryption5.png)
[SHA-1 Rainbow Table](https://sha1.gromweb.com/)  
해시 함수의 특성상 동일한 입력에 대해 항상 동일한 출력을 내보내므로, 레인보우 테이블을 통해 많은 해시값-원문 조합을 미리 계산하고 저장해 놓으면, 해커는 저장된 해시값을 참조하여 빠르게 메시지를 복구할 수 있음

#### 솔트 (Salt) 
해시함수를 돌리기 전에 원문에 덧붙이는 임의의 문자열
![symmetric encryption](/images/cs/encryption6.png)   
원문에 임의의 문자열을 덧붙인 값이 해싱되어 각각 솔트값을 다르게 지정하면 원문이 같더라도 해시값을 다르게 생성
→ 레인보우 테이블과 같은 해시값을 알아내는 방법 우회 가능  

## 🚪 인증 및 인가 메커니즘
### 인증 (Authentication)
> **사용자 또는 디바이스 등의 신원 정보를 확인하는 과정**  
- 사용자가 주장하는 신원이 실제 사용자와 일치하는지 확인 
- ex) ID/PW 입력, 지문 인식, 생체 인식 등 

### 인가 (Authorization, 권한 부여)
> **인증된 사용자가 특정 리소스에 접근할 수 있는 권한을 부여하는 과정**
- ex) 특정 파일 열람, 특정 기능 사용 등 
- 사용자가 자신의 권한 내에서만 리소스에 접근하도록 제한

### PKI (Public Key Infrastructure)
> **공개키 암호화와 전자서명을 안전하게 사용할 수 있도록 신뢰 기반을 마련해주는 체계**  
- 공개키 암호화 기반 구조
  - 사용자마다 비밀키(비공개)와 공개키(공개) 쌍을 가짐
  - 비밀키는 본인만 소유, 공개키는 다른 사람들과 공유
- CA (Certificate Authority, 인증기관)
  - 공개키가 진짜 누구의 것인지 확인해주는 신뢰 기관
  - 인증서를 발급하여 공개키에 디지털 서명을 부여함
- 인증서 (Certificate)
  - 사용자 정보 + 공개키 + CA의 서명이 포함된 문서
  - 인증서 체인을 통해 신뢰가 계층적으로 검증됨  
- PKI 인증과정
![authentication-authorization](/images/cs/authentication-authorization1.png)

### OAuth 2.0 (Open Authorization)   
> **인증을 위한 개방형 표준 프로토콜**  
- 리소스의 API를 이용할 수 있는 권한을 얻는 기술
- 보안수준이 어느정도 검증된 플랫폼의 API를 이용하여 사용자 인증과 리소스에 대한 권한 획득(인가)을 할 수 있도록 해주는 역할을 함
- 어플리케이션이 자격 증명을 공유하지 않고도 사용자를 대신해 서버의 자원에 접근할 수 있음  
- 구글 캘린더 등의 API 이용 권한을 얻을 때 사용
#### OAuth 동작 매커니즘
![authentication-authorization](/images/cs/authentication-authorization2.png)
- OAuth는 인증에 성공한 유저에게 리소스에 대한 접근 권한인 access token만을 제공하지만 유저에 대한 정보는 존재하지 않음
- 유저의 정보를 얻기 위해서는 access token을 얻은 후에 다시 해당 토큰을 가지고 유저의 정보를 요청하는 작업을 해야 함  
→ 이러한 단점으로 생긴 프로토콜이 OIDC

### OpenID Connect (OIDC)
> **OAuth 2.0 위에 추가되는 인증 레이어**  
- 해당 유저의 신원을 검증하는 기술
- 기본적인 흐름은 OAuth 2.0과 완전히 동일하지만 마지막에 access token과 함께 ID token을 추가로 제공하는 부분에서 차이가 발생
- OIDC 인증을 통해 발급된 ID token에는 유저의 프로필, 이메일 등 민감하지 않은 정보들이 포함될 수 있음  
→ 소셜 프로필을 기반으로 회원 정보를 저장하는 애플리케이션일 경우 리소스 서버에 특별히 리소스를 요청하지 않아도 되기 때문에 요청의 수를 절반 이하로 줄일 수 있음
- 소셜 로그인 기능에 사용
#### OIDC 동작 매커니즘
![authentication-authorization](/images/cs/authentication-authorization3.png)

## 🔑 SSL/TLS 프로토콜
### SSL (Secure Scokets Layer) 프로토콜
> **암호화 기반 인터넷 보안 프로토콜**
- 과거 데이터는 가로채면 누구나 읽을 수 있는 일반 텍스트 형태로 전송됨  
→ 보안 이슈 발생, 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 SSL 개발
- 전달되는 모든 데이터를 암호화하고 특정한 유형의 사이버 공격도 차단
- SSL/TLS 를 사용하는 웹사이트 URL은 HTTP 대신 HTTPS가 사용

### TSL (Transport Layer Security) 프로토콜
> **SSL의 업데이트 버전**
- SSL의 최종버전인 3.0과 TLS의 최초버전의 차이는 크지 않음
- SSL을 개발한 Netscape가 업데이트에 참여하지 않게 되어 소유권 변경을 위해서 이름 변경  
→  TLS는 SSL의 업데이트 버전이며 명칭만 다르다고 볼 수 있음

### SSL/TLS의 작동방식
![ssl/tls](/images/cs/ssl-tls.png)
1. Handshake (핸드셰이크)
- 클라이언트가 서버에 접속하면, 클라이언트와 서버는 핸드셰이크 과정을 시작
- 클라이언트는 서버에 암호화 방식과 암호화에 사용할 랜덤 데이터를 전송
- 서버는 클라이언트의 요청에 응답하고, 서버의 공개키와 서버의 정보를 포함한 인증서를 전송
- 클라이언트는 서버의 인증서를 확인하고, 클라이언트에서 생성한 랜덤 데이터와 서버의 랜덤 데이터를 사용하여 세션 키를 생성
2. Key Exchange (키 교환)
- 핸드셰이크 단계에서 생성한 세션 키를 사용하여 통신에 사용할 대칭키 (세션 키)를 교환
- 대칭키는 데이터의 암호화와 복호화에 사용
3. Data Transfer (데이터 전송)
- 데이터가 대칭키를 사용하여 암호화, 네트워크를 통해 전송
- 자신의 개인키로 해당 세션 키를 복호화하여 원래 데이터를 얻음
4. Connection Closure (연결 종료)
- 통신이 끝나면, 클라이언트나 서버 중 한쪽에서 연결 종료 요청을 보냄
- 연결 종료 단계에서는 각 측에서 사용한 키 및 세션 정보를 정리하고 연결을 종료

웹 브라우징 (https), 이메일 통신 (SMTPS, IMAPS, POP3S), 파일 전송 (FTPS) 등에 사용됨

## 🧱 접근 제어 정책
### MAC (Mandatory Access Control, 강제적 접근 제어)
> **주체, 객체 등급기반 접근권한 부여**
- 자원의 보안 레벨과 사용자의 보안 취급 인가를 비교하여 접근 제어
- 어떤 주체가 어떤 객체에 접근하려 할 때 양자의 보안 레벨(보안등급)을 비교하여 높은 보안을 요하는 정보가 낮은 레벨의 주체에게 노출되지 않도록 접근을 제한하는 방법

### DAC (Discretionary Access Control, 임의적 접근 제어)
> **접근 주체 신분기반 접근권한 부여**
- 접근 주체가 속해 있는 그룹의 신원에 근거하여 객체에 대한 접근을 제한
- 자원의 소유자가 접근을 요청하는 사용자의 식별자를 확인하여 객체에 대한 접근을 통제하는 방법

### RBAC (Role-Based Access Control, 역할 기반 접근 제어)
> **주체, 객체 역할기반 권한 부여**
- 주체와 객체가 어떻게 상호작용하는지 결정하기 위해 **중앙**에서 관리되는 통제모음을 사용
- 어떤 주체가 적절한 역할(role)에 할당되고 역할에 적합한 접근권한이 할당된 경우만 객체에 접근할 수 있는 방법
- 비임의적 접근제어(Non DAC)로 전통적인 MAC, DAC의 대체 수단으로 사용

## ☁️ 네트워크 보안
### 방화벽 (Firewall)
> **미리 정의된 보안 규칙에 따라 네트워크로 들어오고 나가는 트래픽을 모니터링하고 제어하는 장치 또는 소프트웨어**
- 불법 접근, 악의적인 데이터 전송, 불필요한 트래픽 낭비를 방지
- 트래픽 필터링, 네트워크 세분화, 감시 및 로깅, 사용자 인증, 프라이버시 보호 등 다양한 기능을 수행

#### 트래픽 필터링(접근 제어)
- 네트워크로 유입되거나 네트워크에서 송출되는 데이터를 특정 규칙에 따라 허용하거나 차단하는 보안 메커니즘
- 네트워크 성능 최적화, 악의적인 데이터 전송 방지, 민감한 정보 보호 등에 사용

#### 인바운드(Inbound) 규칙
- 외부 네트워크에서 내부 네트워크로 들어오는 트래픽을 제어하는 방화벽 규칙
- 관리자 권한으로 특정 프로토콜, IP 주소, 포트를 기준으로 트래픽을 허용하거나 차단할 수 있음
- 모든 포트를 닫는 것이 기본값, 필요에 따라 특정 포트나 서비스 허용

#### 아웃바운드(Outbound) 규칙
- 내부 네트워크에서 외부 네트워크로 나가는 트래픽을 제어하는 방화벽 규칙
- 관리자 권한으로 특정 프로토콜, IP 주소, 포트를 기준으로 트래픽을 허용하거나 차단할 수 있음
- 모든 포트가 허용되는 것이 기본값, 보안을 위해 제한적으로 설정할 필요가 있음

### VPN (Virtual Private Network)
> **물리적으로 전용선이 아닌 공중망을 이용해 논리적으로 직접 연결한 것처럼 망을 구성하는 기술**
- 주로 인터넷과 같은 공중망을 전용선과 같은 사설망처럼 사용하기 위해 도입하므로 강력한 보안을 제공해야 함
- 대부분의 방화벽이나 라우터 장비에 VPN 기능이 포함되어 있음

#### VPN 동작방식
![vpn](/images/cs/vpn1.png)
터널링: 두 노드 혹은 두 네트워크 간에 가상의 링크를 형성하는 기법  
→ 데이터 패킷이 암호화된 보안 터널을 통과하게 만드는 것이 핵심
- 패킷을 터널링 프로토콜로 감싸 통신하는 터널링 기법 사용

### NAC (Network Access Control)
> **네트워크에 접근하는 장치들을 인증하고 보안 상태를 검사하여, 허가되지 않거나 보안에 취약한 장치가 네트워크에 접근하는 것을 방지하는 보안 솔루션**
- 네트워크에 연결된 단말기의 여러가지 정보를 수집하고, 수집된 정보를 바탕으로 단말기들을 분류, 분류한 그룹의 보안위협 정도에 따른 제어를 수행
![vpn](/images/cs/nac.png)

#### NAC 주요기능
1. 안전검사(검역기능)
- Endpoint의 백신보호레벨 및 시스템 패치레벨, 기업이 정해놓은 정책이 맞는지를 검사
2. 인증관리
- Endpoint의 사용자(ID) 네트워크 접근에 대한 인증을 수행
3. 권한관리
- Endpoint의 사용자(ID) 기준 물리적인 접근을 제어
4. 모니터링
- 접속후에도 접속단말의 행위 분석 및 필요시 격리, 치료
- 유해 트래픽 탐지 및 차단, 해킹 행위 차단, 완벽한 증거 수집
5. 장치 통제
- 백신 관리, 패치 관리, 자산 관리(비인가 시스템 자동 검출)  

※ NAC의 접근 제어 및 인증 기능은 일반적으로 MAC 주소를 기반으로 수행

#### NAC 인증절차
1. 네트워크 접근요청 : 접속하고자 하는 PC 사용자는 최초 네트워크에 대한 접근 시도
2. 사용자 및 PC 인증 : MAC 주소를 통해 사용자 PC를 인증하거나 SSO와 연계, 백신 및 패치의 적절성 여부 검토
3. 네트워크 접근 허용 : 인증이 완료되었으면 네트워크 접근 허용
4. 네트워크 접근 거부 : 보안 정책을 준수하지 않았거나 보안에 이상이 있을 경우, 접근 거부 및 격리 됨. 거부 된 PC는 필요한 정책을 준수하고, 보안의 이상을 조치하였을 경우, 다시 점검하여 허용 여부를 재결정

## 🛠️ 보안 사고 대응 프로세스 (Incident Response)
### 보안 사고 대응 프로세스
> **보안 사고 발생 시 사고를 탐지하고, 영향을 최소화하며, 복구하고 재발을 방지하기 위한 일련의 단계**
1. 준비 단계 (Preparation)
- 사고 대응팀 구성 및 역할 정의, 사고 대응 계획 수립 및 문서화, 대응팀 교육 및 훈련 실시, 사고 발생 시 연락 체계 구축
2. 탐지 및 분석 단계 (Detection & Analysis)
- 보안 시스템 및 로그 분석을 통한 이상 징후 탐지
- 사고 유형 및 범위 분석
- 사고의 심각도 및 영향 평가 
3. 격리 및 대응 단계 (Containment & Response)
- 사고 확산 방지를 위한 시스템 격리
- 공격자 차단을 위한 조치 (네트워크 차단, 서비스 중단 등)
- 사고 관련 증거 수집 및 보존
- 사고 대응팀의 초기 대응 및 협력
4. 복구 단계 (Recovery)
- 시스템 복원 및 서비스 재개, 데이터 복구 및 백업, 피해 최소화를 위한 조치
5. 사후 조치 단계 (Post-Incident Activity)
- 사고 원인 분석 및 재발 방지 대책 수립
- 사고 관련 보고서 작성 및 공유
- 사고 대응 프로세스 개선 및 교육 


## 🔍 취약점 스캐닝 및 펜테스트 기초
### 취약점 스캐닝 (Vulnerability Scanning)
> **시스템, 네트워크, 애플리케이션 등에서 보안 취약점을 자동으로 탐지하는 과정**
#### 네트워크 스캐닝
- 포트 스캐닝: Nmap을 사용하여 열려 있는 포트 식별
- 서비스 식별: 열린 포트에서 실행 중인 서비스와 애플리케이션의 버전을 확인하고 취약점(CVE) 탐색
#### 웹 애플리케이션 스캐닝
- 자동화 도구 사용: Burp Suite, OWASP ZAP 등을 사용하여 웹 애플리케이션의 취약점을 자동으로 스캔
- 수동 테스트: 입력 필드에 악의적인 구문을 삽입하거나 예상치 못한 행동을 유도하여 취약점을 수동으로 찾음
#### 취약점 분석
- 결과 분석: 스캐닝 결과를 분석하여 취약점의 심각도를 평가
- 우선순위 지정: 취약점을 우선순위에 따라 정리하고 해결이 필요한 문제를 우선적으로 처리

### 펜테스팅 (Penetration Testing, 침투 테스트)
> **컴퓨터 시스템, 네트워크, 웹 애플리케이션 등의 보안 취약점을 식별하기 위해 모의 해킹 공격을 수행하는 보안 테스트**
- 시스템의 취약점 식별, 위험 수준 평가, 보안 정책의 효과성 검증, 보안 인식 향상 및 대응 훈련 목적

#### 핀테스팅 종류
- Black Box: 내부 정보 없이 외부 해커처럼 테스트
- White Box: 소스코드 / 네트워크 구조 등을 알고 테스트
- Gray Box: 일부 정보만 알고 테스트

#### 공격 단계 (PTES 기반)
1. 정보 수집 (Reconnaissance)
- 도메인, IP, 포트, 서비스 식별 (`nmap`, `whois`)
2. 스캔 및 취약점 분석
- 취약한 버전, 오픈 포트 분석 (`Nessus`, `Nikto`, `OpenVAS`)
3. 익스플로잇 (Exploit)
- 취약점을 이용해 시스템 장악 (`Metasploit`, `manual payloads`)
4. 권한 상승 (Privilege Escalation)
- 관리자 권한 획득 (`kernel exploit`, `token stealing` 등)
5. 내부 정찰 (Internal Recon)
- 도메인 정보, 계정, AD 구조 파악 (`BloodHound`, `Mimikatz`)
6. 지속성 유지 (Persistence)
- 백도어 설치, 스케줄 작업 등록 등
7. 보고서 작성
- 발견된 취약점, 영향도, 대응 방안 정리