---
title: "bmp_parse.exe 익스플로잇"
date: "2024-04-26"
excerpt: "bmp 파일을 인자로 받는 bmp_parse.exe에 주어진 bmp 파일을 변조하여 계산기(calc.exe)를 띄워 익스플로잇하는 프로젝트입니다."
category: "보안"
imageUrl: "images/bmp-parse.png"
award: ""
---

```c
int __cdecl main(int argc, const char **argv, const char **envp){
    if ( argc == 2 ) {
        memset(Src, 0, sizeof(Src));
        v4 = fopen(argv[1], "rb");
        v5 = v4;
        if ( v4 ){
            fread(Buffer, 0x36u, 1u, v4);
            if ( Buffer[0] == 19778 ){
                if ( v13 == 24 ){
                    v6 = 3 * v11 * v12;
                    fseek(v5, Offset, 0);
                    fread(Src, ElementSize, 1u, v5);
                    memcpy(v8, Src, v6);
                    fclose(v5);
                    return 0;
```

fread, memcpy의 size에 해당하는 부분이 변수이기 때문에 취약점 발생을 의심
이때 확인할 것
```
fread(Src, ElementSize, 1u, v5);
memcpy(v8, Src, v6);
```
1. size 변수에 대한 검증이 존재하는가   
2. size 변수를 우리가 조작 가능한가   
1번이 존재한다면 우회할 수 있는지 여부까지 확인 필요   

코드를 보면 ElementSize를 세팅하는 곳이 없음   
memcpy의 인자인 v6은 3 * v11 * v12로 결정됨   
하지만 v11과 v12 변수를 세팅하는 곳이 없음   

```
char pixel_data[4096]; // [esp+4h] [ebp-1140h] BYREF
char dst[260]; // [esp+1004h] [ebp-140h] BYREF
bmp_header bmp_header; // [esp+1108h] [ebp-3Ch] BYREF

size = 3 * bmp_header.width * bmp_header.height;
fread(pixel_data, bmp_header.image_size, 1u, fd);
memcpy(dst, pixel_data, size);
```
코드를 보면 image_size 및 width, height에 대한 검증 없이    
파일에 읽어온 후 그대로 복사하는 것을 확인 가능   
-> stack buffer overflow 발생   

어셈블리 코드를 확인해보면, ret 명령 이전에 __security_check_cookie 함수를 호출하여 스택 쿠키를 검사   
즉 return address를 덮는 방식을 통해선 익스플로잇 불가능   
-> SEH Overwrite 방식을 사용하여 우회   


스택 오버플로우를 통해 0x1a0000 메모리 영역까지 값을 쓸 경우 WRITE 권한이 없기 때문에 memcpy 내부에서 예외가 발생
오버플로우가 시작되는 스택 주소 : 0x19fde8  
스택 다음 맵핑된 메모리 영역 주소: 0x1a0000   
오버플로우가 발생할 크기: 0x1a0000-0x19fde8+1 = 0x219   

대충 width, height를 0x10으로 지정한다면   
3 * 0x10 * 0x10 == 0x300   
image_size를 변경해줘야 pixel_data에 데이터를 넣어주니 비슷하게 0x300으로 변경

width, height: 0x10   
img_size: 0x300   
pixel_data: "A" * 0x17C + 0x00401040(calc 주소)    
오버플로우가 0x219이상 일어나야 예외가 발생하지만 pixel_data는 0x219까지 만큼 채울 필요는 없음   
size 값이 0x300(3 * 0x10 * 0x10)이기 때문에 memcpy가 어차피 0x300 크기만큼 수행될 예정

HxD에서 bmp 파일 수정
-> bmp_parse.exe에 인자로 bmp를 넣어주면 계산기가 실행됨   
![bmp_parse](/images/bmp-parse.png)
